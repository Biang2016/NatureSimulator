//%GenSrc:1:P+D8lcFaO0uyxGpa3x2lyA
/*
 * This code was generated by InstinctAI.
 *
 * It is safe to edit this file.
 */

using System;
using System.Collections.Generic;
using com.kupio.instinctai;
using UnityEngine.UIElements;

namespace instinctai.usr.behaviours
{
    using UnityEngine;

    public partial class Creature : MonoBehaviour
    {
        public GeoGroupInfo MyGeoGroupInfo;

        private int i = 0;

        private void Update()
        {
            if (i < NatureController.Instance.UpdateNFrames)
            {
                i++;
            }
            else
            {
                i = 0;
                UpdateAI();
            }
        }

        [SerializeField] private float size;

        public float Size
        {
            get { return size; }
            set
            {
                size = value;
                if (MyGeoGroupInfo.GeneralSize.Equals(0))
                {
                    int a = 0;
                }

                if (float.IsNaN(size))
                {
                    int a = 0;
                }

                transform.localScale = Vector3.one * size / MyGeoGroupInfo.GeneralSize * 10f;
            }
        }

        [SerializeField] private GeoGroup GeoGroup;
        public Rigidbody2D Rigidbody2D;

        public float BasicSpeed => MyGeoGroupInfo.Speed / 1000f * NatureController.Instance.NormalSpeed;

        public string M_SpeciesName;
        public Species My_Species;

        public void Init(Species species, GeoGroupInfo ci, float _size, bool randomSize = false)
        {
            MyGeoGroupInfo = ci;
            Rigidbody2D.mass = MyGeoGroupInfo.Mass;
            if (randomSize)
            {
                Size = Random.Range(MyGeoGroupInfo.MinSize, MyGeoGroupInfo.MaxSize);
            }
            else
            {
                Size = _size;
            }

            GeoGroup?.PoolRecycle();
            GeoGroup = GameObjectPoolManager.Instance.PoolDict[GameObjectPoolManager.PrefabNames.GeoGroup].AllocateGameObject<GeoGroup>(transform);

            My_Species = species;
            M_SpeciesName = species.MyGeoGroupInfo.Name;

            foreach (GeoInfo gi in species.MyGeoGroupInfo.GeoInfos)
            {
                GeoElement ge = GameObjectPoolManager.Instance.PoolDict[GameObjectPoolManager.PrefabNames.GeoElement].AllocateGameObject<GeoElement>(GeoGroup.transform);
                ge.Collider.enabled = false;
                GeoGroup.AllGeos.Add(ge);
                GeoGroup.GeoGroupInfo = species.MyGeoGroupInfo;
                ge.transform.localPosition = (gi.Position - ci.Center) / GameManager.Instance.ScaleFactor / GameManager.Instance.ScaleFactor;
                ge.transform.rotation = gi.Rotation;
                ge.Initialize(gi.GeoType, gi.Size, gi.Color, gi.SortingOrder);
            }

            MyCollider.radius = MyGeoGroupInfo.ColliderRadius;
        }

        [SerializeField] private CircleCollider2D MyCollider;

        void OnDestroy()
        {
            GeoGroup.PoolRecycle();
            GeoGroup = null;
        }

        public bool IsPreyOf(Creature o)
        {
            if (MyGeoGroupInfo.Predators.Contains(o.M_SpeciesName))
            {
                return true;
                //return Size < NatureController.Instance.EatSizeThreshold * o.Size;
            }
            else
            {
                return false;
            }
        }

        public bool IsPredatorOf(Creature o)
        {
            if (MyGeoGroupInfo.Diets.Contains(o.M_SpeciesName))
            {
                return true;
                //return Size * NatureController.Instance.EatSizeThreshold > o.Size;
            }
            else
            {
                return false;
            }
        }

        public bool IsMateOf(Creature o)
        {
            if (o.M_SpeciesName == M_SpeciesName && o.Size > MyGeoGroupInfo.MateMatureSizeThreshold && Size > MyGeoGroupInfo.MateMatureSizeThreshold)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        public bool Destroyed = false;

        public NodeVal GrowUp()
        {
            if (Destroyed) return NodeVal.Success;
            Size = Mathf.Min(MyGeoGroupInfo.MaxSize, MyGeoGroupInfo.GrowUpRate * Size * Time.deltaTime + Size);
            try
            {
                if (Vector2.Distance(transform.position, Vector2.zero) > 5.40f * 2)
                {
                    NatureController.Instance.DestroyCreature(this);
                }
            }
            catch
            {
            }

            return NodeVal.Success;
        }

        public void Valid(bool valid)
        {
            this.valid = valid;
        }

        private void OnCollisionEnter2D(Collision2D other)
        {
            Creature o = other.gameObject.GetComponent<Creature>();
            if (o != null)
            {
                if (o.IsPreyOf(this))
                {
                    Size = (int) Mathf.Sqrt(Size * Size + o.Size * o.Size * NatureController.Instance.NutritionRatio);
                    NatureController.Instance.DestroyCreature(o);
                    return;
                }

                if (o.IsMateOf(this))
                {
                    if (My_Species.Creatures.Count >= MyGeoGroupInfo.MaxNumber) return;
                    Creature mother = o.Size > Size ? o : this;
                    Creature father = o.Size > Size ? this : o;

                    int hi_p = MyGeoGroupInfo.FertilityRate % 100;
                    int low = MyGeoGroupInfo.FertilityRate / 100;
                    int rand = Random.Range(0, 100);
                    if (hi_p > rand) low++;

                    for (int i = 0; i < low; i++)
                    {
                        My_Species.SpawnCreatures(MyGeoGroupInfo.OffspringSizePercent / 100f * mother.Size, transform.position, false);
                    }

                    float motherLeftSize = 1f - (MyGeoGroupInfo.OffspringSizePercent / 100f * MyGeoGroupInfo.OffspringSizePercent / 100f) * low;
                    motherLeftSize = Mathf.Max(0.1f, motherLeftSize);
                    mother.Size = Mathf.Sqrt(motherLeftSize) * mother.Size;
                    father.Size = Mathf.Sqrt(motherLeftSize) * father.Size;

                    return;
                }
            }
        }

        #region AvoidPredators

        public Vector3 escapingFrom = new Vector3(0, 0);

        public NodeVal FindPredators()
        {
            Creature predator = NatureController.Instance.FindNearestPredator(this);
            if (predator)
            {
                escapingFrom = predator.transform.position;
                return NodeVal.Success;
            }
            else
            {
                return NodeVal.Fail;
            }
        }

        public NodeVal MoveToEscape()
        {
            isWandering = false;
            Rigidbody2D.velocity = Vector3.Normalize(-escapingFrom + transform.position) * BasicSpeed * NatureController.Instance.EscapingSpeedFactor;
            return NodeVal.Success;
        }

        #endregion

        #region ChasePreys  

        public Vector3 preyLocation = new Vector3(0, 0);

        public NodeVal FindPreys()
        {
            Creature prey = NatureController.Instance.FindNearestPrey(this);
            if (prey)
            {
                preyLocation = prey.transform.position;
                return NodeVal.Success;
            }
            else
            {
                return NodeVal.Fail;
            }
        }

        public NodeVal MoveToPrey()
        {
            isWandering = false;
            Rigidbody2D.velocity = Vector3.Normalize(preyLocation - transform.position) * BasicSpeed * NatureController.Instance.ChasingSpeedFactor;
            return NodeVal.Success;
        }

        #endregion

        #region Mate

        public Vector3 mateDestination = new Vector3(0, 0);
        private float MateTick = 0f;
        private bool ReadyToMate = false;

        public NodeVal FindMate()
        {
            if (MateTick < NatureController.Instance.MateTimeInterval)
            {
                MateTick += Time.deltaTime;
            }
            else
            {
                ReadyToMate = true;
            }

            if (!ReadyToMate) return NodeVal.Fail;

            if (My_Species.Creatures.Count > MyGeoGroupInfo.MaxNumber)
            {
                return NodeVal.Fail;
            }

            if (Size < MyGeoGroupInfo.MateMatureSizeThreshold)
            {
                return NodeVal.Fail;
            }

            Creature mateDot = My_Species.FindNearestMate(this);
            if (mateDot != null)
            {
                mateDestination = mateDot.transform.position;
                MateTick = 0;
                ReadyToMate = false;
                return NodeVal.Success;
            }
            else
            {
                return NodeVal.Fail;
            }
        }

        public NodeVal MoveToMate()
        {
            isWandering = false;
            Rigidbody2D.velocity = Vector3.Normalize(mateDestination - transform.position) * BasicSpeed * NatureController.Instance.FindingMateSpeedFactor;
            return NodeVal.Success;
        }

        #endregion

        #region  Wandering

        public Vector3 wanderDestination = new Vector3(0, 0);

        public bool isWandering = false;
        private float wanderTime = 0f;

        public NodeVal Wander()
        {
            if (!isWandering)
            {
                isWandering = true;
                wanderDestination = NatureController.GetRandomPos(Size);
                wanderTime = 0f;
            }
            else
            {
                wanderTime += Time.deltaTime;
                if (wanderTime > 2f)
                {
                    isWandering = false;
                }

                if (Vector3.Distance(transform.position, wanderDestination) < 0.2f)
                {
                    isWandering = false;
                }
            }

            return NodeVal.Success;
        }

        public NodeVal MoveToWander()
        {
            Rigidbody2D.velocity = Vector3.Normalize(wanderDestination - transform.position) * BasicSpeed * NatureController.Instance.WanderingSpeedFactor;
            return NodeVal.Success;
        }

        #endregion
    }
}